{"posts":[{"title":"7.11暑期模拟赛","content":"预估分数： T1 T2 T3 Sum 100 100 100 300 实际分数： T1 T2 T3 Sum 100 100 100 300 （吐槽T3数据，要不是有人发现了数据BUG就痛失AK） T1 Chain 第一问统计叶子树，第二问直接依题意树形DP上来，签到题。 Tips：题面提示说注意可能有必要写手写栈，然后我就用的Tuopu，结果递归的也都过了，我因为用了STL比有些小常数递归的还慢（ T2 Prefix 算法：KMP+DP 计数题，考虑DP，子串，考虑定义状态 f[i]f[i]f[i] 为 以 iii 结尾的合法子串数量。 朴素方程： f[i]=∑j=2,2∣ji[s[1…j]=s[i−j+1…i]]f[i] = \\sum_{j = 2 , 2 \\mid j}^{i} [s[1\\ldots j] = s[i - j + 1 \\ldots i]] f[i]=j=2,2∣j∑i​[s[1…j]=s[i−j+1…i]] 可以发现这个check是个前缀等于后缀的形式，考虑利用 KMP 里的 next⁡\\operatorname{next}next 数组 那么就是： f[i]={f[next⁡[i]]+12∣if[next⁡[i]]2∤if[i] = \\begin{cases} f[\\operatorname{next}[i]] + 1 &amp; 2 \\mid i\\\\ f[\\operatorname{next}[i]] &amp; 2\\nmid i \\end{cases} f[i]={f[next[i]]+1f[next[i]]​2∣i2∤i​ T3 Motor 很显然的分层图模型，这里采用二维 Dij ","link":"https://your-dawn.github.io/post/711-shu-qi-mo-ni-sai/"},{"title":"7.10暑期模拟赛","content":"期望得分 T1 T2 T3 Sum 100 0 100 200 实际得分： T1 T2 T3 Sum 0 0 60 60 惨（woshiSB T1 Comic 算法：树型DP，组合计数 树上计数，考虑DP 感觉从后往前填比较好填，所以把儿子倒过来 很显然每个儿子互相独立，考虑怎么合并到根上 首先填儿子 yyy ，显然只有一种填法，那么接下来的 (Siz⁡y−1\\operatorname{Siz}_y - 1Sizy​−1) 个 就可以填到 yyy 后面的任意一个空 那么就是 P⁡(Siz⁡x+Siz⁡y−2Siz⁡y−1)\\operatorname{P}(_{\\operatorname{Siz}_x + \\operatorname{Siz}_y - 2}^{\\operatorname{Siz}_y - 1})P(Sizx​+Sizy​−2Sizy​−1​) 但是这样可能会不满足子孙的前后限制，所以还要除一个 P⁡(Siz⁡y−1Siz⁡y−1)\\operatorname{P}(_{\\operatorname{Siz}_y - 1}^{\\operatorname{Siz}_y - 1})P(Sizy​−1Sizy​−1​) 所以DP方程： f[x]=∑y∈sonf[y]∗C⁡(Siz⁡x+Siz⁡y−2Siz⁡y−1)f[x] = \\sum_{y \\in son}f[y] * \\operatorname{C}(_{\\operatorname{Siz}_x + \\operatorname{Siz}_y - 2}^{\\operatorname{Siz}_y - 1}) f[x]=y∈son∑​f[y]∗C(Sizx​+Sizy​−2Sizy​−1​) Tips：错误原因：做插空法的时候考虑总“空隙数”错误 T2 Worried 首先差分，考虑 [2,x][2,x][2,x] 怎么求 首先想到的是枚每个数最多能多少次方，但这样要枚 10910^9109 ，不可行 考虑枚举次数，那么难点来到怎么求 xk\\sqrt[k]{x}kx​ ，考虑二分，但二分过程中会爆longlong（似乎可以避免，但感觉处理起来很麻烦，不管了） 然后我就感觉这个思路也G了，就没往下想了，下面给出来自 Ew_Cors 与 zzm 的两种思路。 思路1：考虑STL的pow(x,1k⁡)\\operatorname{pow(x, \\frac{1}{k}})pow(x,k1​) （才知道pow⁡\\operatorname{pow}pow 能求 nnn 次根），但这样可能有精度问题，所以需要左右调整一下 思路2：222 次方可以直接 sqrt⁡\\operatorname{sqrt}sqrt ，333 次方及以上最多 10610^6106 个，所以其实可以直接枚举 但要注意的是，这样求出来的只是 “能够被表示为 kkk 次方” 的数，并没有保证最大，所以需要容斥。 可以发现这个容斥和 Dirichlet⁡\\operatorname{Dirichlet}Dirichlet 前缀和很像： f[i]=f[i]−∑j&gt;1f[i∗j]f[i] = f[i] - \\sum_{j &gt; 1}{f[i * j]} f[i]=f[i]−j&gt;1∑​f[i∗j] Tips: 日常数据范围没算准，觉得想不到方法的时候可以算一下范围，以防想复杂 当时也没完全相当用容斥，只觉得这东西很难去重，容斥技巧仍需加强 T3 CF 考场上稍微手玩一下，发现第一列可以随便填，考虑其他列填每个位置有什么不同。 0100100000100001\\begin{matrix} \\color{red}{0} &amp; 1 &amp; 0 &amp; 0\\\\ 1 &amp; \\color{red}{0} &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix}0100​1000​0010​0001​ 若第二个 000 填在标红的位置，则剩余的矩阵将形成一个 n−2n - 2n−2 的子问题 若填到未标红位置，相当于不能填红色位置，如果将它也看作一个障碍的话，那就是一个 n−1n - 1n−1 的子问题 那么可以考虑DP f[i]=(n−1)×(f[i−1]+f[i−2])f[i] = (n - 1) \\times (f[i - 1] + f[i - 2]) f[i]=(n−1)×(f[i−1]+f[i−2]) 可以发现，这个DP方程，正好也是错排问题的递推式，那么此题是否与错排问题有关呢？ 由上面的分析可以发现，答案与矩阵到底是什么样子无关，只与 nnn 有关，所以可以将此矩形特殊化为对角线为1的矩形。 那么就是错排问题的模型了。 Tips：由于此题没给模数，要用高精，然后高精写挂了（，来自 WoshiSB 的小技巧：不需要压位且复杂度较充裕时，可以直接用加法代替乘法 ","link":"https://your-dawn.github.io/post/710-shu-qi-mo-ni-sai/"},{"title":"快速傅里叶变换(FFT)","content":" 部分内容参考文献 本文作者dxbdly\\text{dxbdly}dxbdly，引用或转载请注明原文链接 1. 前言 FFT\\text{FFT}FFT 是一种用来实现 DFT\\text{DFT}DFT（离散傅里叶变换）的高效算法。 它一般用于加速多项式乘法，可使其达到 O(nlog⁡n)O(n\\log n)O(nlogn) 的速度，有时也用于加速大整数乘法。 注：FFTFFTFFT 算法涉及较多前置数学知识，本文仅会介绍重要的前置知识，其他不清楚的请读者自行百度。 2. 前置知识1：多项式表示法 1o1^o1o 系数表示法 通常，我们表示多项式的方式是系数表示法，即使用一个系数数列来表示多项式。 也就是形如： f(x)=a0+a1x+a2x2+…+anxnf(x) = a_0 + a_1x + a_2x^2+\\ldots+a_nx^n f(x)=a0​+a1​x+a2​x2+…+an​xn 即： f(x)={a0,a1,a2…,an}f(x) = \\{a_0,a_1,a_2\\ldots,a_n\\} f(x)={a0​,a1​,a2​…,an​} 但如果依照这种表示方式进行多项式乘法，乘积的系数数列会十分复杂，难以研究。 所以我们考虑使用其他方式表示多项式。 2o2^o2o 点值表示法 我们把多项式看成一个函数，由于我们可以使用 n+1n + 1n+1 个此函数上的点，来唯一表示此函数。 也就是说，这 n+1n + 1n+1 个点同样可以唯一表示此多项式。 也就是当： f(x0)=a0+a1x0+a2x02+…+anx0nf(x1)=a0+a1x1+a2x12+…+anx1nf(x2)=a0+a1x2+a2x22+…+anx2n⋮f(xn)=a0+a1xn+a2xn2+…+anxnnf(x_0) = a_0 + a_1x_0 + a_2x_0^2 + \\ldots + a_nx_0^n\\\\ f(x_1) = a_0 + a_1x_1 + a_2x_1^2 + \\ldots + a_nx_1^n\\\\ f(x_2) = a_0 + a_1x_2 + a_2x_2^2 + \\ldots + a_nx_2^n\\\\ \\vdots\\\\ f(x_n) = a_0 + a_1x_n + a_2x_n^2 + \\ldots + a_nx_n^n f(x0​)=a0​+a1​x0​+a2​x02​+…+an​x0n​f(x1​)=a0​+a1​x1​+a2​x12​+…+an​x1n​f(x2​)=a0​+a1​x2​+a2​x22​+…+an​x2n​⋮f(xn​)=a0​+a1​xn​+a2​xn2​+…+an​xnn​ 就有： f(x)={(x0,f(x0)),(x1,f(x1)),(x2,f(x2)),…,(xn,f(xn))}f(x) = \\{(x_0, f(x_0)), (x_1, f(x_1)), (x_2, f(x_2)), \\ldots , (x_n, f(x_n))\\} f(x)={(x0​,f(x0​)),(x1​,f(x1​)),(x2​,f(x2​)),…,(xn​,f(xn​))} 这样表示有何好处呢？ 我们会发现，在点值表示法下，多项式的乘积将很好表示。 设：有两多项式 f(x)={(x0,f(x0)),(x1,f(x1)),…,(xn,f(xn))}f(x) = \\{(x_0, f(x_0)), (x_1, f(x_1)), \\ldots ,(x_n, f(x_n))\\}f(x)={(x0​,f(x0​)),(x1​,f(x1​)),…,(xn​,f(xn​))} 与 g(x)={(x0,g(x0)),(x1,g(x1)),…,(xn,g(xn))}g(x) = \\{(x_0, g(x_0)), (x_1, g(x_1)), \\ldots ,(x_n, g(x_n))\\}g(x)={(x0​,g(x0​)),(x1​,g(x1​)),…,(xn​,g(xn​))} 那么乘积 F(x)F(x)F(x) 可表示为： F(x)={(x0,f(x0)×g(x0)),(x1,f(x1)×g(x1)),…,(xn,f(xn)×g(xn))}F(x) = \\{(x_0, f(x_0) \\times g(x_0)), (x_1, f(x_1) \\times g(x_1)), \\ldots , (x_n, f(x_n)\\times g(x_n))\\} F(x)={(x0​,f(x0​)×g(x0​)),(x1​,f(x1​)×g(x1​)),…,(xn​,f(xn​)×g(xn​))} 也就是说，如果我们能将 f(x)f(x)f(x) 与 g(x)g(x)g(x) 表示为点值表示法，那么就能用 O(n)O(n)O(n) 的时间求出 F(x)F(x)F(x) 的点值表示。 那么留给我们的就是两个问题： 如何将 f(x)f(x)f(x) 与 g(x)g(x)g(x) 从系数表示变为点值表示 如何将 F(x)F(x)F(x) 从点值表示变回系数表示 <!-- more --> 3. 前置知识2：单位复根 我们发现，在解决这两个问题之前，我们需要先找出 n+1n + 1n+1 个点 并且它们适于我们进行转换，换句话说，我们希望这 n+1n + 1n+1 个点满足某种规律，且对所有多项式都适用。 在这里，我们需要引入一个概念—— 单位复根 1o1^o1o 单位复根的定义 PS：不知道复数是什么的读者请看。 下面附上手写的复数类型，包括复数的三种运算： 我们称 wn=1w^n = 1wn=1 在复数意义下的解为 nnn 次复根。 显然，这样的复根有 nnn 个，我们记它们为 {wnk∣k=0,1,2,…,n−1}\\{w_n^k | k = 0,1,2,\\ldots,n - 1\\}{wnk​∣k=0,1,2,…,n−1} 我们考虑这个方程的几何意义： 在复平面上作一个单位圆，则此单位圆上的复数向量模长都为 111 所以我们可以将 www 理解成复平面上的一个单位向量，它的俯角的 nnn 倍正好是 360o360^o360o wnw_nwn​ 就是 单位复根，且这 nnn 次复根将这个圆周 nnn 等分。 所以，我们可以利用俯角求出 wnw_nwn​ ： wn=cos⁡(2πn)+i×sin⁡(2πn)w_n = \\cos(\\frac{2\\pi}{n}) + i \\times \\sin(\\frac{2\\pi}{n}) wn​=cos(n2π​)+i×sin(n2π​) 2o2^o2o 单位复根的性质 单位复根有三个重要的性质： 对于任意正整数 nnn 与整数 kkk，有： wnn=1w_n^n = 1wnn​=1 解释：相当于转一周回到原点。 wnk=w2n2kw_n^k = w_{2n}^{2k}wnk​=w2n2k​ 解释：在 nnn 份中取 kkk 份与 w2nk+n=−w2nkw_{2n}^{k + n} = -w_{2n}^{k}w2nk+n​=−w2nk​ 解释：相当于转半圈，坐标取反 wna+wnb=wna+bw_{n}^{a} + w_{n}^{b} = w_{n}^{a+b}wna​+wnb​=wna+b​ 解释：分别取 aaa 份与 bbb 份显然就是共取 a+ba+ba+b 份 后续的 DFT\\text{DFT}DFT 推导过程中，需要反复运用这三个式子，请好好理解。 4. DFT\\text{DFT}DFT 确定了要带入的 n+1n + 1n+1 个点后，我们先来解决系数表示变点值表示的问题。 这个过程称为 DFT\\text{DFT}DFT 。 如果直接带入点，复杂度仍是 O(n2)O(n ^ 2)O(n2) 的，不能接受。 由于我们取的点是存在规律的，我们考虑能否一次性将所有点的函数值求出。 1o1^o1o 分治 DFT\\text{DFT}DFT 很自然的想到了分治。 这里积累一种套路：如果要对多项式分治，可以考虑尝试将奇数项与偶数项分开，构造子问题。 举个例子： 设：$$F(x) = a_0 + a_1x + a_2x^2 + \\ldots + a_7x^7$$ 奇偶分组： F(x)=(a0+a2x2+a4x4+a6x6)+(a1x+a3x3+a5x5+a7x7)=(a0+a2x2+a4x4+a6x6)+x(a1+a3x2+a5x4+a7x6)F(x) = (a_0 + a_2x^2 + a_4x^4 + a_6x^6) + (a_1x + a_3x^3 + a_5x^5 + a_7x^7)\\\\ \\quad\\quad=(a_0 + a_2x^2 + a_4x^4 + a_6x^6) + x(a_1 + a_3x^2 + a_5x^4 + a_7x^6) F(x)=(a0​+a2​x2+a4​x4+a6​x6)+(a1​x+a3​x3+a5​x5+a7​x7)=(a0​+a2​x2+a4​x4+a6​x6)+x(a1​+a3​x2+a5​x4+a7​x6) 可以发现两部分都是 F(x)F(x)F(x) 的子结构。 设：$$ G(x) = a_0 + a_2x + a_4x^2 + a_6x^3\\ H(x) = a_1 + a_3x + a_5x^2 + a_7x^3 用 $G(x)$ 与 $H(x)$ 表示 $F(x)$ ： $$F(x) = G(x^2) + xH(x^2) 接下来，考虑带入点 wnkw_n^kwnk​ ： F(wnk)=G((wnk)2)+wnkH((wnk)2)=G(wn2k)+wnkH(wn2k)=G(wn/2k)+wnkH(wn/2k)F(w_n^k) = G((w_n^k)^2) + w_n^kH((w_n^k)^2)\\\\ \\quad= G(w_n^{2k}) + w_n^kH(w_n^{2k})\\\\ \\quad\\quad= G(w_{n/2}^k) + w_n^kH(w_{n/2}^k) F(wnk​)=G((wnk​)2)+wnk​H((wnk​)2)=G(wn2k​)+wnk​H(wn2k​)=G(wn/2k​)+wnk​H(wn/2k​) 由于要在 O(nlog⁡n)O(n\\log n)O(nlogn) 的时间内，所以每次需要将求解的范围缩小。 考虑单位复根性质 333 ，则可尝试表示 F(wnk+2/n)F(w_n^{k+2/n})F(wnk+2/n​) F(wnk+n/2)=G(wn2k+n)+wnk+n/2H(wn2k+n) =G(wn2k)+wnk+n/2H(wn2k)=G(wn2k)−wnkH(wn2k)=G(wn/2k)−wnkH(wn/2k)F(w_n^{k+n/2}) = G(w_n^{2k+n}) + w_n^{k+n/2}H(w_n^{2k+n})\\\\ \\quad\\quad\\;\\;= G(w_n^{2k}) + w_n^{k+n/2}H(w_n^{2k})\\\\ \\quad= G(w_n^{2k}) - w_n^kH(w_n^{2k})\\\\ \\quad\\quad\\quad= G(w_{n/2}^{k}) - w_n^kH(w_{n/2}^{k}) F(wnk+n/2​)=G(wn2k+n​)+wnk+n/2​H(wn2k+n​)=G(wn2k​)+wnk+n/2​H(wn2k​)=G(wn2k​)−wnk​H(wn2k​)=G(wn/2k​)−wnk​H(wn/2k​) 这样，我们就可以用 G(wn/2k)G(w_{n/2}^k)G(wn/2k​) 与 H(wn/2k)H(w_{n/2}^k)H(wn/2k​) 同时算出两个值，保证了 O(nlog⁡n)O(n\\log n)O(nlogn) 的复杂度。 2o2^o2o 位逆序置换(蝴蝶变换) 上面的分治算法虽以达到 O(nlog⁡n)O(n \\log n)O(nlogn) 的复杂度。 可实际上由于要使用递归，并且需传输大量的数组，指针，实现起来常数巨大。 我们考虑将其用迭代实现，这样，我们就可以从最后的状态倍增的向上合并。 也就是说，我们首先要想办法求出最后分组的状态，也就是确定合并的顺序。 举个例子： 原数列：{x0,x1,x2,…,x8}\\{x_0,x_1,x_2,\\ldots,x_8\\}{x0​,x1​,x2​,…,x8​} 最终数列：{x0}{x4}{x2}{x6}{x1}{x5}{x3}{x7}\\{x_0\\}\\{x_4\\}\\{x_2\\}\\{x_6\\}\\{x_1\\}\\{x_5\\}\\{x_3\\}\\{x_7\\}{x0​}{x4​}{x2​}{x6​}{x1​}{x5​}{x3​}{x7​} 而这个序列是有规律的： 对于原来的序列，将每个数用二进制表示，然后将二进制翻转，就是对应的最终位置的下标 我们称这种翻转为位逆序置换，又称蝴蝶变换 根据定义，很容易想到用 O(nlog⁡n)O(n \\log n)O(nlogn) 的方式求解每个数变换后的结果。 但是这还不够，实际上，我们可以通过递推求出 111 到 nnn 的位逆序置换值。 设：R(x)R(x)R(x) 表示 xxx 在 111 到 nnn 中的位逆序置换值 边界： R(0)=0R(0) = 0R(0)=0 考虑转移，将 xxx 的翻转分为其个位的翻转与个位前的翻转，即：x mod 2x \\bmod 2xmod2 的翻转与 ⌊x2⌋\\lfloor\\frac{x}{2}\\rfloor⌊2x​⌋ 的翻转 则有： R(x)=⌊R(⌊x2⌋)2⌋+(x mod 2)×n2R(x) = \\lfloor\\frac{R(\\lfloor\\frac{x}{2}\\rfloor)}{2}\\rfloor + (x \\bmod 2) \\times \\frac{n}{2} R(x)=⌊2R(⌊2x​⌋)​⌋+(xmod2)×2n​ 注意： ⌊R(⌊x2⌋)2⌋\\lfloor\\frac{R(\\lfloor\\frac{x}{2}\\rfloor)}{2}\\rfloor⌊2R(⌊2x​⌋)​⌋ 是因为去掉个位反转后，首位补的 000 会翻转到个位，要去掉。 (x mod 2)×n2(x \\bmod 2) \\times \\frac{n}{2}(xmod2)×2n​ 则是如果个位为 111 ，那么首位为 111 ，否则补 000 。 位逆序置换部分代码： 这样就可以用 O(n)O(n)O(n) 的时间预处理，然后按照 DFT\\text{DFT}DFT 的过程将其合并就好，具体实现后面会讲。 5. IDFT\\text{IDFT}IDFT IDFT\\text{IDFT}IDFT，即傅里叶反变换算法，它可以解决将点值表示变回系数表示的问题。 它与 DFT\\text{DFT}DFT 算法极为类似，实现时一般也写在一起（后面细讲）。 1o1^o1o 线性代数意义下的 DFT\\text{DFT}DFT 与 IDFT\\text{IDFT}IDFT 可以发现，DFTDFTDFT 本质是一个线性变换，我们尝试将这个过程用矩阵表示出来： [y0y1y2⋮yn]=[111…11wn1wn2…wnn−11wn2wn4…wn2(n−1)⋮⋮⋮⋱⋮1wnn−1wn2(n−1)…wn(n−1)2][a0a1a2⋮an−1]\\left[ \\begin{matrix} y_0\\\\ y_1\\\\ y_2\\\\ \\vdots\\\\ y_n \\end{matrix} \\right] = \\left[ \\begin{matrix} 1 &amp; 1 &amp; 1 &amp; \\ldots &amp; 1\\\\ 1 &amp; w_n^1 &amp; w_n^2 &amp; \\ldots &amp; w_n^{n - 1} \\\\ 1 &amp; w_n^2 &amp; w_n^4 &amp; \\ldots &amp; w_n^{2(n - 1)} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp;\\ddots &amp; \\vdots \\\\ 1 &amp; w_n^{n - 1} &amp; w_n^{2(n - 1)} &amp; \\ldots &amp; w_n^{(n - 1) ^ 2} \\end{matrix} \\right] \\left[ \\begin{matrix} a_0 \\\\ a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_{n - 1} \\end{matrix} \\right] ⎣⎢⎢⎢⎢⎢⎡​y0​y1​y2​⋮yn​​⎦⎥⎥⎥⎥⎥⎤​=⎣⎢⎢⎢⎢⎢⎢⎡​111⋮1​1wn1​wn2​⋮wnn−1​​1wn2​wn4​⋮wn2(n−1)​​………⋱…​1wnn−1​wn2(n−1)​⋮wn(n−1)2​​⎦⎥⎥⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎢⎡​a0​a1​a2​⋮an−1​​⎦⎥⎥⎥⎥⎥⎤​ 现在我们相当于知道 yyy 点值矩阵 与 wniw_n^iwni​ 点矩阵，要求 aaa 系数矩阵。 同时乘上 wniw_n^iwni​ 的逆矩阵，也就是这样： [y0y1y2⋮yn][1n1n1n…1n1n1wn11wn2…1wnn−11n1wn21wn4…1wn2(n−1)⋮⋮⋮⋱⋮1n1wnn−11wn2(n−1)…1wn(n−1)2]=[a0a1a2⋮an−1]\\left[ \\begin{matrix} y_0\\\\ y_1\\\\ y_2\\\\ \\vdots\\\\ y_n \\end{matrix} \\right] \\left[ \\begin{matrix} \\frac{1}{n} &amp; \\frac{1}{n} &amp; \\frac{1}{n} &amp; \\ldots &amp; \\frac{1}{n}\\\\ \\frac{1}{n} &amp; \\frac{1}{w_n^1} &amp; \\frac{1}{w_n^2} &amp; \\ldots &amp; \\frac{1}{w_n^{n - 1}} \\\\ \\frac{1}{n} &amp; \\frac{1}{w_n^2} &amp; \\frac{1}{w_n^4} &amp; \\ldots &amp; \\frac{1}{w_n^{2(n - 1)}} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp;\\ddots &amp; \\vdots \\\\ \\frac{1}{n} &amp; \\frac{1}{w_n^{n - 1}} &amp; \\frac{1}{w_n^{2(n - 1)}} &amp; \\ldots &amp; \\frac{1}{w_n^{(n - 1) ^ 2}} \\end{matrix} \\right] = \\left[ \\begin{matrix} a_0 \\\\ a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_{n - 1} \\end{matrix} \\right] ⎣⎢⎢⎢⎢⎢⎡​y0​y1​y2​⋮yn​​⎦⎥⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎢⎢⎡​n1​n1​n1​⋮n1​​n1​wn1​1​wn2​1​⋮wnn−1​1​​n1​wn2​1​wn4​1​⋮wn2(n−1)​1​​………⋱…​n1​wnn−1​1​wn2(n−1)​1​⋮wn(n−1)2​1​​⎦⎥⎥⎥⎥⎥⎥⎤​=⎣⎢⎢⎢⎢⎢⎡​a0​a1​a2​⋮an−1​​⎦⎥⎥⎥⎥⎥⎤​ 这就是 IDFT\\text{IDFT}IDFT 的矩阵表示，可以发现，这是个类似 DFT\\text{DFT}DFT 的矩阵。 所以，我们只需要将所有 wnkw_n^kwnk​ 改为 1wnk\\frac{1}{w_n^k}wnk​1​ 就好了。 而根据定义： 1wnk=cos⁡(2πk)+i×sin⁡(−2πk)\\frac{1}{w_n^k} = \\cos(\\frac{2\\pi}{k}) + i\\times\\sin(-\\frac{2\\pi}{k}) wnk​1​=cos(k2π​)+i×sin(−k2π​) 所以，我们只要在 DFT\\text{DFT}DFT 中带一个标记，就可以实现 IDFT\\text{IDFT}IDFT 的功能。 2o2^o2o DFT\\text{DFT}DFT 与 IDFT\\text{IDFT}IDFT 的实现 自己写的时候容易晕，注解一下各个循环在枚举什么，先上代码： 注意： opopop 为标志变量，用于区分 DFT\\text{DFT}DFT 与 IDFT\\text{IDFT}IDFT。 第一层循环， hhh 枚举的是当前合并层每一组的数量，其中 stepstepstep 为单位复数。 第二层循环， iii 枚举的是每一组的编号起点 第三层循环， kkk 枚举的是当前要求解的下标（另一个是 k+h/2k + h / 2k+h/2） 注意这里用了滚动数组，并没有新记录 GGG 函数与 HHH 函数。 6. 例题 一道模板题： 模板题 代码为了图方便封装过了的。 代码： 几个要注意的点： FFT\\text{FFT}FFT 几乎所有的操作都要求在 lenlenlen 为 222 的整数幂下进行，所以需要对多项式先补 000 STL\\text{STL}STL 的复数类型很慢，这里直接自己写的，三种运算，应该算基础吧。 最后关于精度，四舍五入输出，大部分时候 double\\text{double}double 够用。 7. The End\\text{The End}The End 刚学的 FFT\\text{FFT}FFT ，没做什么题，文章有不对的地方请私信博主。 最后，FFT\\text{FFT}FFT 是一种很重要的多项式算法，之后的许多多项式有关的算法都可以用 FFT\\text{FFT}FFT 优化。 其中有许多算法思想更是值得我们学习。 解决 DFT\\text{DFT}DFT 问题的算法还有很多，例如 快速数论变换(NTT)，MTT\\text{MTT}MTT（任意模数 NTT\\text{NTT}NTT），FWT\\text{FWT}FWT（快速沃尔什变换） 但这些算法都是以 FFT\\text{FFT}FFT 为基础衍生而来，所以读者需要将 FFT\\text{FFT}FFT 理解清楚后进行深入的学习 希望本文对大家有所帮助，感谢观看。 部分内容参考文献 本文作者dxbdly\\text{dxbdly}dxbdly，引用或转载请注明原文链接 Q.E.D\\text{Q.E.D} Q.E.D ","link":"https://your-dawn.github.io/post/kuai-su-fu-li-xie-bian-huan-fft/"},{"title":"快速数论变换(NTT)","content":" 部分内容参考文献 本文作者dxbdly⁡\\operatorname{dxbdly}dxbdly，引用或转载请注明原文链接 1. 前言 上篇文章，我们介绍了求解多项式乘法的一种算法 FFT\\text{FFT}FFT，不清楚的读者请阅读文章 但FFT\\text{FFT}FFT需要用到复数类，常数较大且容易出现精度误差。 而NTT\\text{NTT}NTT可以很好的解决这两个问题，它是一种基于 原根 进行DFT\\text{DFT}DFT的算法。 2. 原根 NTT\\text{NTT}NTT仍采取点值表示，研究数值表示转点值表示，点值表示转数值表示两个问题。 解决这两个问题的方法，与 FFT\\text{FFT}FFT 完全一样，只不过 NTT\\text{NTT}NTT 改变了点值表示中取的点。 它采取 原根 代替单位复根，以此避免复数计算 1o1^o1o 阶 若 a⊥pa \\perp pa⊥p ，且 p&gt;1p &gt; 1p&gt;1 ，则称满足 an≡1(modp)a ^ n \\equiv 1 \\pmod pan≡1(modp) 的最小的 nnn 为 aaa 在模 ppp 意义下的阶，记为 δp(a)\\delta_p(a)δp​(a) 2o2^o2o 原根的定义 对于正整数 ppp ，整数 aaa ，若满足 δp(a)=ϕ(p)\\delta_p(a) = \\phi(p)δp​(a)=ϕ(p) ，则称 aaa 为模 ppp 意义下的原根 注意： 原根个数不唯一，且如果模数 ppp 有原根，则必有 ϕ(ϕ(p))\\phi(\\phi(p))ϕ(ϕ(p)) (不重要，不证了) 后文 ggg 均指模 ppp 意义下的原根 3o3 ^ o3o 原根的性质 前面提到了，我们希望用原根代替单位根，那么，先要构造一个不重复的 n+1n + 1n+1 项序列。 重要性质： 若 ppp 为质数，那么 gi mod p(1&lt;g&lt;p,0&lt;i&lt;p)g^i \\bmod p(1 &lt; g &lt; p, 0 &lt; i &lt; p)gimodp(1&lt;g&lt;p,0&lt;i&lt;p) 各不相同 证明：考虑费马小定理：gp−1≡1(modp)g^{p - 1} \\equiv 1\\pmod pgp−1≡1(modp) 所以只要取 gnig_n^igni​ 即可满足，但我们在 FFT\\text{FFT}FFT 中还用到了关于单位复根的几个性质。 可以发现原根均可满足： 所以： wnw_nwn​ 在模 ppp 意义下有： wn=gp−1n(modp)w_n = g^{\\frac{p - 1}{n}} \\pmod p wn​=gnp−1​(modp) 3. NTT\\text{NTT}NTT 实现 DFT\\text{DFT}DFT 与 IDFT\\text{IDFT}IDFT 由于 NTT\\text{NTT}NTT 要在模意义下进行，所以我们得先选好模数。 我们一般选择模数为 998244353998244353998244353 ，它的原根是 333 ，逆元是 332748118332748118332748118 对于 DFT\\text{DFT}DFT ，将所有 wnw_nwn​ 换为 gng_ngn​ 即可，记得每一步操作都需要取模。 对于 IDFT\\text{IDFT}IDFT ，还是构造逆矩阵，将 gng_ngn​ 的底数改为逆元，可同理与 DFT\\text{DFT}DFT 一起进行，注意输出时要乘 nnn 的逆元 4. 模板 模板题 代码： 注意： 全部都需取模，中间运算可能爆 int\\text{int}int，要开 longlong\\text{longlong}longlong 。 5. The End\\text{The End}The End NTT\\text{NTT}NTT 是一种从 FFT\\text{FFT}FFT ，发展而来的算法，需要读者对 FFT\\text{FFT}FFT 有比较清晰的了解。 NTT\\text{NTT}NTT 的缺点与优点很明显： 优点：NTT\\text{NTT}NTT 常数更小，且不需要进行复数运算，精度误差小。 缺点：NTT\\text{NTT}NTT 十分依赖模数，如果题目对模数有限制，则只能考虑 FFT\\text{FFT}FFT 或 MTT\\text{MTT}MTT (任意模数 NTT\\text{NTT}NTT ) 作为多项式乘法中可以说最常用的算法，需要大家仔细了解。 希望此文章能给您带来帮助，感谢观看。 部分内容参考文献 本文作者dxbdly\\text{dxbdly}dxbdly，引用或转载请注明原文链接 Q.E.D\\text{Q.E.D} Q.E.D ","link":"https://your-dawn.github.io/post/kuai-su-shu-lun-bian-huan-ntt/"},{"title":"新博客来了！😘","content":"本人 Dawn\\text{Dawn}Dawn ，坐标HN，一名YL-Oier 以后所有博客都在这里更新😃 ","link":"https://your-dawn.github.io/post/hello-gridea/"}]}